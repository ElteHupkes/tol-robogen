/*
 * TouchSensorModel.cpp
 *
 *  Created on: Mar 27, 2015
 *      Author: elte
 */

#include <tol_robogen/model/components/perceptive/TouchSensorModel.h>

#include <sdf_builder/sensor/Sensor.h>

#include <tol_robogen/model/io/Sensor.h>

namespace sb = sdf_builder;

namespace tol_robogen {

const float TouchSensorModel::MASS = 3;
const float TouchSensorModel::SENSOR_BASE_WIDTH = 34;
const float TouchSensorModel::SENSOR_BASE_THICKNESS = 1.5;
const float TouchSensorModel::SENSOR_THICKNESS = 9;
const float TouchSensorModel::SENSOR_WIDTH = 18.5; // Of each left/right sensors
const float TouchSensorModel::SENSOR_HEIGHT = 16;

TouchSensorModel::~TouchSensorModel() {}

// TODO We could make this component a lot easier on the physics engine
// if we estimate the entire component's inertia (using MeshLab for
// instance) and add a bunch of collision objects instead of multiple
// links. This is true for various other components as well.
bool TouchSensorModel::initModel() {
	// Add the sensor root
	this->sensorRoot_ = this->createLink(B_SENSOR_BASE_ID);

	double baseThickness = inMm(SENSOR_BASE_THICKNESS);
	double baseWidth = inMm(SENSOR_BASE_WIDTH);
	double mass = inGrams(MASS);

	this->sensorRoot_->makeBox(mass, baseThickness, baseWidth, baseWidth);

	// Add the left and right sensor parts

	double thickness = inMm(SENSOR_THICKNESS);
	double width = inMm(SENSOR_WIDTH);
	double height = inMm(SENSOR_HEIGHT);

	double xSensors = baseThickness / 2 + thickness / 2;
	double yLeftSensor = -width / 2 - inMm(1);
	double yRightSensor = width / 2 + inMm(1);

	sensorHelper(B_SENSOR_LEFT, mass, thickness, width,
			height, xSensors, yLeftSensor, "left_sensor", 0);
	sensorHelper(B_SENSOR_RIGHT, mass, thickness, width,
			height, xSensors, yRightSensor, "right_sensor", 1);

	return true;
}

void TouchSensorModel::sensorHelper(unsigned int id,
		double mass, double thickness, double width, double height,
		double xSensors, double ySensor, std::string name,
		unsigned int ioId) {
	// Create the sensor link
	auto sensorLink = this->createLink(id);
	sensorLink->makeBox(mass, thickness, width, height);
	sensorLink->position(sb::Vector3(xSensors, ySensor, 0));
		this->fixLinks(this->sensorRoot_, sensorLink,
			sb::Vector3(xSensors, ySensor, 0));

	auto sensor = this->createSensor(name, "contact");
	// The collision element generated by "makeBox" is called "collision"
	std::string sensorDetails = "<contact>"
			"<collision>collision</collision>"
			"</contact>";

	sensor->addString(sensorDetails);
	sensorLink->addPosable(sensor);

	// TODO I don't think noise on this sensor is currently possible,
	//      but it should be considered in one way or another.

	// Add the I/O instance represented by this sensor
	IOPtr io(new Sensor(id_, ioId, "touch", sensor, sensorLink));
	this->addIO(io);
}

sdf_builder::LinkPtr TouchSensorModel::getRoot() {
	return sensorRoot_;
}

sdf_builder::LinkPtr TouchSensorModel::getSlot(unsigned int i) {
	checkSlot(i);
	return sensorRoot_;
}

sdf_builder::Vector3 TouchSensorModel::getSlotPosition(unsigned int i) {
	checkSlot(i);
	auto rootPosition = sensorRoot_->position();
	auto axis = this->getSlotAxis(i);

	return rootPosition + axis * (inMm(SENSOR_BASE_THICKNESS) / 2);
}

sdf_builder::Vector3 TouchSensorModel::getSlotOrientation(unsigned int i) {
	checkSlot(i);
	return sensorRoot_->rotation() * sb::Vector3(0, 1, 0);
}

sdf_builder::Vector3 TouchSensorModel::getSlotAxis(unsigned int i) {
	checkSlot(i);
	return sensorRoot_->rotation() * sb::Vector3(-1, 0, 0);
}



void TouchSensorModel::checkSlot(unsigned int i) {
	if (i > 1) {
		std::cerr << "[TouchSensorModel] Invalid slot: " << i << std::endl;
		throw std::runtime_error("Sensor error");
	}
}

} /* namespace tol_robogen */
